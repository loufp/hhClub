# Поддерживаемые языки и экосистемы — документация

Цель этого документа — подробно описать логику определения языка и фреймворка, показать примеры файлов конфигурации, которые анализируются, привести таблицу соответствия языков и build-инструментов и документировать шаблоны пайплайнов, используемые генератором.

Содержание:
- Обзор логики определения
- Поддерживаемые языки и детальная логика
  - Java / Kotlin
  - Node.js / TypeScript
  - Python
  - Go
  - C# (.NET) — кратко
- Примеры конфигурационных файлов, которые анализируются
- Таблица соответствия: язык ↔ build-инструмент
- Описание шаблонов пайплайнов (Jenkinsfile, .gitlab-ci.yml)
- Рекомендации по кэшу и средам выполнения
- Быстрые команды и примеры

---

## 1. Обзор логики определения

Анализатор использует двухуровневый подход:

1. Смотрит на конфигурационные файлы в корне репозитория (приоритет): `pom.xml`, `build.gradle`, `package.json`, `pyproject.toml`, `requirements.txt`, `go.mod`, `*.csproj` и т.д. На этом этапе извлекаются зависимости, версии и build-инструменты.

2. Если конфигов мало или они отсутствуют, выполняется поиск по файловой структуре и содержимому исходников: `src/test`, файлы с тестами, импортами/аннотациями (`import org.junit`, `@Test`, `import pytest` и т.д.). Это позволяет определить фреймворк даже без явной зависимости.

Дополнительно анализируются:
- `Dockerfile` и `docker-compose` для обнаружения контейнерных настроек и портов
- `settings.gradle`, `pnpm-workspace.yaml`, `package.json` → workspace detection
- Наличие `README*`, `.gitlab-ci.yml`, `Jenkinsfile` для рекомендаций

---

## 2. Поддерживаемые языки и логика определения

### Java / Kotlin

Файлы для анализа:
- `pom.xml` — Maven
- `build.gradle`, `build.gradle.kts` — Gradle
- `settings.gradle(.kts)` — multi-module

Логика:
- Парсинг `pom.xml` через XML (XDocument). Извлекаем `groupId:artifactId`, `version`, `dependencies`, `properties` (например, `java.version`).
- Для Gradle применяем regex-паттерны на `implementation`, `api`, `testImplementation` и т.д.; для Kotlin — проверка `kotlin-stdlib`/`kotlinVersion`.
- Определение фреймворков по зависимостям: `spring-boot-starter*` → Spring Boot, `io.quarkus` → Quarkus, `io.micronaut` → Micronaut.
- Тесты: поиск зависимостей `junit`, `testng`, `kotest`. Также анализ `src/test` файлов на `@Test`, `import org.junit`.
- Coverage: поиск `jacoco` в зависимостях или плагинах.

Пример (фрагмент pom.xml):

```xml
<dependency>
  <groupId>org.junit.jupiter</groupId>
  <artifactId>junit-jupiter</artifactId>
  <version>5.9.3</version>
  <scope>test</scope>
</dependency>
```

### Node.js / TypeScript

Файлы для анализа:
- `package.json` — dependencies и devDependencies
- `tsconfig.json` — TypeScript
- `pnpm-lock.yaml`, `yarn.lock`, `package-lock.json`

Логика:
- Чтение `package.json`, извлечение `dependencies` и `devDependencies`. Сохраняем имя и версию в `result.Dependencies`.
- Определение фреймворка по пакету: `react` → React, `next` → Next.js, `express` → Express.js, `@nestjs/*` → NestJS.
- Тесты: наличие `jest`, `mocha`, `vitest`, `cypress` в dependencies или в файлах `*.test.js/ts`, `*.spec.js/ts`, `__tests__`.
- Coverage: `nyc`, `istanbul`, `c8`, или тест-фреймворки с флагом `--coverage`.

Пример (фрагмент package.json):

```json
{
  "devDependencies": {
    "jest": "^29.0.0",
    "@types/jest": "^29.0.0"
  }
}
```

### Python

Файлы для анализа:
- `pyproject.toml` — Poetry / PEP 621
- `requirements.txt` — pip
- `setup.py` — legacy

Логика:
- Для `pyproject.toml` анализируем секции `[project.dependencies]` и `[tool.poetry.dependencies]`. Игнорируем `[project.scripts]` и другие секции.
- Для `requirements.txt` парсим строки формата `package==version`, `package>=version`, `package`.
- Определение фреймворков: `django`, `flask`, `fastapi`.
- Тесты: `pytest`, `unittest`, `nose` — из зависимостей или по файлам `test_*.py` и каталогу `tests/`.
- Coverage: `coverage`, `pytest-cov`.

Пример (фрагмент requirements.txt):

```
pytest==7.4.0
coverage==7.2.0
flask>=2.2
```

### Go

Файлы для анализа:
- `go.mod` — go modules

Логика:
- Парсер ищет `require` блоки и одиночные require-строки; извлекает модули и версии.
- Определение фреймворков: `github.com/gin-gonic/gin` → Gin, `github.com/gofiber/fiber` → Fiber.
- Тесты: файлы `*_test.go` и импорты `testing`; дополнительные фреймворки `testify`, `ginkgo` распознаются по модулям.
- Coverage: поиск `coverage.out` или рекомендации использовать `go test -cover`.

Пример (фрагмент go.mod):

```
require (
  github.com/gin-gonic/gin v1.9.0
)
```

### C# (.NET) — кратко

Файлы для анализа:
- `*.csproj`

Логика:
- Парсинг XML проекта для `PackageReference` → извлечение зависимостей и версий.
- Тесты: `MSTest`, `NUnit`, `xUnit` по PackageReference.

---

## 3. Примеры файлов конфигурации, которые анализируются

- Java: `pom.xml`, `build.gradle`, `settings.gradle`
- Kotlin: `build.gradle.kts`, `settings.gradle.kts`
- Node.js/TS: `package.json`, `tsconfig.json`, `pnpm-workspace.yaml`, `package-lock.json`, `yarn.lock`
- Python: `pyproject.toml`, `requirements.txt`, `setup.py`
- Go: `go.mod`
- .NET: `*.csproj`

---

## 4. Таблица соответствия: язык ↔ build-инструмент

| Язык | Build-инструмент | Конфиг |
|------|------------------|--------|
| Java | Maven | `pom.xml` |
| Java | Gradle | `build.gradle` / `build.gradle.kts` |
| Kotlin | Gradle | `build.gradle.kts` |
| Node.js / TypeScript | npm / yarn / pnpm | `package.json`, `yarn.lock`, `pnpm-lock.yaml` |
| Python | pip / Poetry | `requirements.txt`, `pyproject.toml` |
| Go | Go Modules | `go.mod` |
| C# (.NET) | dotnet (msbuild) | `*.csproj` |

---

## 5. Шаблоны пайплайнов и их логика

В проекте лежат шаблоны для Jenkins и GitLab CI. Шаблоны используют плейсхолдеры, которые заполняются результатами анализа.

Общие плейсхолдеры (пример):
- `{{IMAGE}}` / `{{DOCKER_IMAGE}}` — базовый образ для agent'а
- `{{BUILD_CMDS_JENKINS}}` / `{{BUILD_COMMANDS_JENKINS}}` — команды сборки
- `{{TEST_CMDS_JENKINS}}` / `{{TEST_COMMANDS_JENKINS}}` — команды тестирования
- `{{CI_REGISTRY}}`, `{{JOB_NAME}}`, `{{BUILD_NUMBER}}` — переменные окружения CI

Структура этапов (типовой):
1. Checkout
2. Restore dependencies / prepare cache
3. Build
4. Test
5. Static analysis (SonarQube)
6. Package / Docker build
7. Publish artifacts (Nexus, Registry)
8. Deploy to staging (placeholder)
9. Deploy to production (manual gate)

Примеры для Java (Jenkins):
- `BUILD_CMDS_JENKINS`: `mvn -B -DskipTests package`
- `TEST_CMDS_JENKINS`: `mvn test`
- `Docker build`: `docker build -t $DOCKER_IMAGE_NAME .`

Примеры для Node.js (Jenkins):
- `BUILD_CMDS_JENKINS`: `npm ci && npm run build`
- `TEST_CMDS_JENKINS`: `npm test`

Примеры для Python (Jenkins):
- `BUILD_CMDS_JENKINS`: `pip install -r requirements.txt`
- `TEST_CMDS_JENKINS`: `pytest --junitxml=report.xml`

GitLab CI: шаблон формирует stages аналогично и добавляет cache для `~/.m2`, `~/.npm`, `~/.cache/pip`.

---

## 6. Рекомендации по кэшу и средам выполнения

Рекомендованные директории для кэширования:
- Maven: `~/.m2/repository`
- Gradle: `~/.gradle/caches` и `~/.gradle/wrapper`
- npm: `~/.npm` или локальный cache
- pip: `~/.cache/pip`
- Go: `$(go env GOMODCACHE)` или `$GOPATH/pkg/mod`

Рекомендации по агентам Jenkins:
- Для универсальности используйте agent-ноды с установленным набором инструментов (Java, Maven, Node, Docker, Python, Go).
- Можно создать Docker-образ агента с предустановленными инструментами.

---

## 7. Быстрые команды и примеры

Запуск локальной инфраструктуры:

```bash
docker-compose -f docker-compose.simple.yml up -d
```

Остановка и удаление контейнеров (с сохранением volumes):

```bash
docker-compose -f docker-compose.simple.yml down
```

Сборка и тестирование локально для Java-проекта (пример):

```bash
cd path/to/project
mvn -B -DskipTests package
mvn test
```

Запуск анализа сгенерированного Jenkinsfile локально: сначала настройте Jenkins и Jenkins agent с необходимыми инструментами, затем импортируйте pipeline.

---

## 8. Что осталось сделать (рекомендации)

- Добавить формальные диаграммы архитектуры (sequence/flow) в `SYSTEM_ARCHITECTURE.md`.
- Примеры готовых `Jenkinsfile`/`.gitlab-ci.yml` для типовых проектов (minimal, java-spring, node-react).
- Скрипт создания готового Jenkins agent Docker image с предустановленными инструментами.

---

Файл создан автоматически. Если нужно, расширю разделы конкретными шаблонами или диаграммами и добавлю примеры `Jenkinsfile`/`.gitlab-ci.yml` в папку `examples/`.

